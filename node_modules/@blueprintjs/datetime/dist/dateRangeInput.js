/*
 * Copyright 2017 Palantir Technologies, Inc. All rights reserved.
 * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy
 * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE
 * and https://github.com/palantir/blueprint/blob/master/PATENTS
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var classNames = require("classnames");
var moment = require("moment");
var React = require("react");
var core_1 = require("@blueprintjs/core");
var dateUtils_1 = require("./common/dateUtils");
var datePickerCore_1 = require("./datePickerCore");
var dateRangePicker_1 = require("./dateRangePicker");
;
;
var DateRangeInput = (function (_super) {
    tslib_1.__extends(DateRangeInput, _super);
    function DateRangeInput(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.displayName = "Blueprint.DateRangeInput";
        _this.refHandlers = {
            endInputRef: function (ref) {
                _this.endInputRef = ref;
                core_1.Utils.safeInvoke(_this.props.endInputProps.inputRef, ref);
            },
            startInputRef: function (ref) {
                _this.startInputRef = ref;
                core_1.Utils.safeInvoke(_this.props.startInputProps.inputRef, ref);
            },
        };
        // Callbacks - DateRangePicker
        // ===========================
        _this.handleDateRangePickerChange = function (selectedRange) {
            if (_this.props.value === undefined) {
                var _a = dateUtils_1.fromDateRangeToMomentDateRange(selectedRange), selectedStart = _a[0], selectedEnd = _a[1];
                var isOpen = true;
                var isStartInputFocused = void 0;
                var isEndInputFocused = void 0;
                var startHoverString = void 0;
                var endHoverString = void 0;
                if (dateUtils_1.isMomentNull(selectedStart)) {
                    // focus the start field by default or if only an end date is specified
                    isStartInputFocused = true;
                    isEndInputFocused = false;
                    // for clarity, hide the hover string until the mouse moves over a different date
                    startHoverString = null;
                }
                else if (dateUtils_1.isMomentNull(selectedEnd)) {
                    // focus the end field if a start date is specified
                    isStartInputFocused = false;
                    isEndInputFocused = true;
                    endHoverString = null;
                }
                else if (_this.props.closeOnSelection) {
                    isOpen = false;
                    isStartInputFocused = false;
                    isEndInputFocused = false;
                }
                else if (_this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.START) {
                    // keep the start field focused
                    isStartInputFocused = true;
                    isEndInputFocused = false;
                }
                else {
                    // keep the end field focused
                    isStartInputFocused = false;
                    isEndInputFocused = true;
                }
                _this.setState({
                    isOpen: isOpen,
                    selectedEnd: selectedEnd,
                    selectedStart: selectedStart,
                    isEndInputFocused: isEndInputFocused,
                    isStartInputFocused: isStartInputFocused,
                    startHoverString: startHoverString,
                    endHoverString: endHoverString,
                    endInputString: _this.getFormattedDateString(selectedEnd),
                    startInputString: _this.getFormattedDateString(selectedStart),
                    wasLastFocusChangeDueToHover: false,
                });
            }
            core_1.Utils.safeInvoke(_this.props.onChange, selectedRange);
        };
        _this.handleDateRangePickerHoverChange = function (hoveredRange) {
            if (hoveredRange == null) {
                // undo whatever focus changes we made while hovering
                // over various calendar dates
                var isEndInputFocused_1 = (_this.state.boundaryToModify === dateUtils_1.DateRangeBoundary.END);
                var isStartInputFocused_1 = !isEndInputFocused_1;
                var lastFocusedField = (isEndInputFocused_1) ? dateUtils_1.DateRangeBoundary.END : dateUtils_1.DateRangeBoundary.START;
                _this.setState({
                    isEndInputFocused: isEndInputFocused_1,
                    isStartInputFocused: isStartInputFocused_1,
                    lastFocusedField: lastFocusedField,
                    endHoverString: null,
                    startHoverString: null,
                });
                return;
            }
            var _a = _this.state, selectedStart = _a.selectedStart, selectedEnd = _a.selectedEnd, boundaryToModify = _a.boundaryToModify;
            var _b = dateUtils_1.fromDateRangeToMomentDateRange(hoveredRange), hoveredStart = _b[0], hoveredEnd = _b[1];
            var _c = [hoveredStart, hoveredEnd].map(_this.getFormattedDateString), startHoverString = _c[0], endHoverString = _c[1];
            var _d = [hoveredStart, hoveredEnd].map(function (d) { return !dateUtils_1.isMomentNull(d); }), isHoveredStartDefined = _d[0], isHoveredEndDefined = _d[1];
            var _f = [selectedStart, selectedEnd].map(function (d) { return !dateUtils_1.isMomentNull(d); }), isStartDateSelected = _f[0], isEndDateSelected = _f[1];
            var isModifyingStartBoundary = boundaryToModify === dateUtils_1.DateRangeBoundary.START;
            // pull the existing values from state; we may not overwrite them.
            var _g = _this.state, isStartInputFocused = _g.isStartInputFocused, isEndInputFocused = _g.isEndInputFocused;
            if (isStartDateSelected && isEndDateSelected) {
                if (isHoveredStartDefined && isHoveredEndDefined) {
                    if (_this.areSameDay(hoveredStart, selectedStart)) {
                        // we'd be modifying the end date on click
                        isStartInputFocused = false;
                        isEndInputFocused = true;
                    }
                    else if (_this.areSameDay(hoveredEnd, selectedEnd)) {
                        // we'd be modifying the start date on click
                        isStartInputFocused = true;
                        isEndInputFocused = false;
                    }
                }
                else if (isHoveredStartDefined) {
                    if (isModifyingStartBoundary) {
                        // we'd be specifying a new start date and clearing the end date on click
                        isStartInputFocused = true;
                        isEndInputFocused = false;
                    }
                    else {
                        // we'd be deselecting the end date on click
                        isStartInputFocused = false;
                        isEndInputFocused = true;
                    }
                }
                else if (isHoveredEndDefined) {
                    if (isModifyingStartBoundary) {
                        // we'd be deselecting the start date on click
                        isStartInputFocused = true;
                        isEndInputFocused = false;
                    }
                    else {
                        // we'd be specifying a new end date (clearing the start date) on click
                        isStartInputFocused = false;
                        isEndInputFocused = true;
                    }
                }
            }
            else if (isStartDateSelected) {
                if (isHoveredStartDefined && isHoveredEndDefined) {
                    if (_this.areSameDay(hoveredStart, selectedStart)) {
                        // we'd be modifying the end date on click, so focus the end field
                        isStartInputFocused = false;
                        isEndInputFocused = true;
                    }
                    else if (_this.areSameDay(hoveredEnd, selectedStart)) {
                        // we'd be modifying the start date on click, so focus the start field
                        isStartInputFocused = true;
                        isEndInputFocused = false;
                    }
                }
                else if (isHoveredStartDefined) {
                    // we'd be replacing the start date on click
                    isStartInputFocused = true;
                    isEndInputFocused = false;
                }
                else if (isHoveredEndDefined) {
                    // we'd be converting the selected start date to an end date
                    isStartInputFocused = false;
                    isEndInputFocused = true;
                }
            }
            else if (isEndDateSelected) {
                if (isHoveredStartDefined && isHoveredEndDefined) {
                    if (_this.areSameDay(hoveredEnd, selectedEnd)) {
                        // we'd be modifying the start date on click
                        isStartInputFocused = true;
                        isEndInputFocused = false;
                    }
                    else if (_this.areSameDay(hoveredStart, selectedEnd)) {
                        // we'd be modifying the end date on click
                        isStartInputFocused = false;
                        isEndInputFocused = true;
                    }
                }
                else if (isHoveredEndDefined) {
                    // we'd be replacing the end date on click
                    isStartInputFocused = false;
                    isEndInputFocused = true;
                }
                else if (isHoveredStartDefined) {
                    // we'd be converting the selected end date to a start date
                    isStartInputFocused = true;
                    isEndInputFocused = false;
                }
            }
            _this.setState({
                startHoverString: startHoverString,
                endHoverString: endHoverString,
                isStartInputFocused: isStartInputFocused,
                isEndInputFocused: isEndInputFocused,
                lastFocusedField: (isStartInputFocused) ? dateUtils_1.DateRangeBoundary.START : dateUtils_1.DateRangeBoundary.END,
                wasLastFocusChangeDueToHover: true,
            });
        };
        // Callbacks - Input
        // =================
        // Key down
        // add a keydown listener to persistently change focus when tabbing:
        // - if focused in start field, Tab moves focus to end field
        // - if focused in end field, Shift+Tab moves focus to start field
        _this.handleInputKeyDown = function (e) {
            var isTabPressed = e.keyCode === core_1.Keys.TAB;
            var isShiftPressed = e.shiftKey;
            // order of JS events is our enemy here. when tabbing between fields,
            // this handler will fire in the middle of a focus exchange when no
            // field is currently focused. we work around this by referring to the
            // most recently focused field, rather than the currently focused field.
            var wasStartFieldFocused = _this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.START;
            var wasEndFieldFocused = _this.state.lastFocusedField === dateUtils_1.DateRangeBoundary.END;
            var isEndInputFocused;
            var isStartInputFocused;
            // move focus to the other field
            if (wasStartFieldFocused && isTabPressed && !isShiftPressed) {
                isStartInputFocused = false;
                isEndInputFocused = true;
            }
            else if (wasEndFieldFocused && isTabPressed && isShiftPressed) {
                isStartInputFocused = true;
                isEndInputFocused = false;
            }
            else {
                // let the default keystroke happen without side effects
                return;
            }
            // prevent the default focus-change behavior to avoid race conditions;
            // we'll handle the focus change ourselves in componentDidUpdate.
            e.preventDefault();
            _this.setState({
                isStartInputFocused: isStartInputFocused,
                isEndInputFocused: isEndInputFocused,
                wasLastFocusChangeDueToHover: false,
            });
        };
        // Mouse down
        _this.handleInputMouseDown = function () {
            // clicking in the field constitutes an explicit focus change. we update
            // the flag on "mousedown" instead of on "click", because it needs to be
            // set before onFocus is called ("click" triggers after "focus").
            _this.setState({ wasLastFocusChangeDueToHover: false });
        };
        // Click
        _this.handleInputClick = function (e) {
            // unless we stop propagation on this event, a click within an input
            // will close the popover almost as soon as it opens.
            e.stopPropagation();
        };
        // Focus
        _this.handleStartInputFocus = function (e) {
            _this.handleInputFocus(e, dateUtils_1.DateRangeBoundary.START);
        };
        _this.handleEndInputFocus = function (e) {
            _this.handleInputFocus(e, dateUtils_1.DateRangeBoundary.END);
        };
        _this.handleInputFocus = function (_e, boundary) {
            var _a = _this.getStateKeysAndValuesForBoundary(boundary), keys = _a.keys, values = _a.values;
            var inputString = _this.getFormattedDateString(values.selectedValue);
            // change the boundary only if the user explicitly focused in the field.
            // focus changes from hovering don't count; they're just temporary.
            var boundaryToModify = (_this.state.wasLastFocusChangeDueToHover)
                ? _this.state.boundaryToModify
                : boundary;
            _this.setState((_b = {
                    isOpen: true,
                    boundaryToModify: boundaryToModify
                },
                _b[keys.inputString] = inputString,
                _b[keys.isInputFocused] = true,
                _b.lastFocusedField = boundary,
                _b.wasLastFocusChangeDueToHover = false,
                _b));
            var _b;
        };
        // Blur
        _this.handleStartInputBlur = function (e) {
            _this.handleInputBlur(e, dateUtils_1.DateRangeBoundary.START);
        };
        _this.handleEndInputBlur = function (e) {
            _this.handleInputBlur(e, dateUtils_1.DateRangeBoundary.END);
        };
        _this.handleInputBlur = function (_e, boundary) {
            var _a = _this.getStateKeysAndValuesForBoundary(boundary), keys = _a.keys, values = _a.values;
            var maybeNextValue = _this.dateStringToMoment(values.inputString);
            var isValueControlled = _this.isControlled();
            if (_this.isInputEmpty(values.inputString)) {
                if (isValueControlled) {
                    _this.setState((_b = {},
                        _b[keys.isInputFocused] = false,
                        _b[keys.inputString] = _this.getFormattedDateString(values.controlledValue),
                        _b));
                }
                else {
                    _this.setState((_c = {},
                        _c[keys.isInputFocused] = false,
                        _c[keys.selectedValue] = moment(null),
                        _c[keys.inputString] = null,
                        _c));
                }
            }
            else if (!_this.isNextDateRangeValid(maybeNextValue, boundary)) {
                if (isValueControlled) {
                    _this.setState((_d = {}, _d[keys.isInputFocused] = false, _d));
                }
                else {
                    _this.setState((_f = {},
                        _f[keys.isInputFocused] = false,
                        _f[keys.inputString] = null,
                        _f[keys.selectedValue] = maybeNextValue,
                        _f));
                }
                core_1.Utils.safeInvoke(_this.props.onError, _this.getDateRangeForCallback(maybeNextValue, boundary));
            }
            else {
                _this.setState((_g = {}, _g[keys.isInputFocused] = false, _g));
            }
            var _b, _c, _d, _f, _g;
        };
        // Change
        _this.handleStartInputChange = function (e) {
            _this.handleInputChange(e, dateUtils_1.DateRangeBoundary.START);
            core_1.Utils.safeInvoke(_this.props.startInputProps.onChange, e);
        };
        _this.handleEndInputChange = function (e) {
            _this.handleInputChange(e, dateUtils_1.DateRangeBoundary.END);
            core_1.Utils.safeInvoke(_this.props.endInputProps.onChange, e);
        };
        _this.handleInputChange = function (e, boundary) {
            var inputString = e.target.value;
            var keys = _this.getStateKeysAndValuesForBoundary(boundary).keys;
            var maybeNextValue = _this.dateStringToMoment(inputString);
            var isValueControlled = _this.isControlled();
            if (inputString.length === 0) {
                // this case will be relevant when we start showing the hovered
                // range in the input fields. goal is to show an empty field for
                // clarity until the mouse moves over a different date.
                if (isValueControlled) {
                    _this.setState((_a = {}, _a[keys.inputString] = "", _a));
                }
                else {
                    _this.setState((_b = {}, _b[keys.inputString] = "", _b[keys.selectedValue] = moment(null), _b));
                }
                core_1.Utils.safeInvoke(_this.props.onChange, _this.getDateRangeForCallback(moment(null), boundary));
            }
            else if (_this.isMomentValidAndInRange(maybeNextValue)) {
                // note that error cases that depend on both fields (e.g.
                // overlapping dates) should fall through into this block so that
                // the UI can update immediately, possibly with an error message on
                // the other field.
                if (isValueControlled) {
                    _this.setState((_c = {}, _c[keys.inputString] = inputString, _c));
                }
                else {
                    _this.setState((_d = {}, _d[keys.inputString] = inputString, _d[keys.selectedValue] = maybeNextValue, _d));
                }
                if (_this.isNextDateRangeValid(maybeNextValue, boundary)) {
                    core_1.Utils.safeInvoke(_this.props.onChange, _this.getDateRangeForCallback(maybeNextValue, boundary));
                }
            }
            else {
                _this.setState((_f = {}, _f[keys.inputString] = inputString, _f));
            }
            var _a, _b, _c, _d, _f;
        };
        // Callbacks - Popover
        // ===================
        _this.handlePopoverClose = function () {
            _this.setState({ isOpen: false });
        };
        _this.dateStringToMoment = function (dateString) {
            if (_this.isInputEmpty(dateString)) {
                return moment(null);
            }
            return moment(dateString, _this.props.format);
        };
        _this.getInitialRange = function (props) {
            if (props === void 0) { props = _this.props; }
            var defaultValue = props.defaultValue, value = props.value;
            if (value != null) {
                return dateUtils_1.fromDateRangeToMomentDateRange(value);
            }
            else if (defaultValue != null) {
                return dateUtils_1.fromDateRangeToMomentDateRange(defaultValue);
            }
            else {
                return [moment(null), moment(null)];
            }
        };
        _this.getSelectedRange = function () {
            var momentDateRange = [_this.state.selectedStart, _this.state.selectedEnd];
            var _a = momentDateRange.map(function (selectedBound) {
                return _this.isMomentValidAndInRange(selectedBound)
                    ? dateUtils_1.fromMomentToDate(selectedBound)
                    : undefined;
            }), startDate = _a[0], endDate = _a[1];
            // show only the start date if the dates overlap
            // TODO: add different handling for the === case once
            // allowSingleDayRange is implemented (#249)
            return [startDate, (startDate >= endDate) ? null : endDate];
        };
        _this.getInputDisplayString = function (boundary) {
            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;
            var isInputFocused = values.isInputFocused, inputString = values.inputString, selectedValue = values.selectedValue, hoverString = values.hoverString;
            if (hoverString != null && !_this.isControlled()) {
                // we don't want to overwrite the inputStrings in controlled mode
                return hoverString;
            }
            else if (isInputFocused) {
                return (inputString == null) ? "" : inputString;
            }
            else if (dateUtils_1.isMomentNull(selectedValue)) {
                return "";
            }
            else if (!_this.isMomentInRange(selectedValue)) {
                return _this.props.outOfRangeMessage;
            }
            else if (_this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {
                return _this.props.overlappingDatesMessage;
            }
            else {
                return _this.getFormattedDateString(selectedValue);
            }
        };
        _this.getFormattedDateString = function (momentDate) {
            if (dateUtils_1.isMomentNull(momentDate)) {
                return "";
            }
            else if (!momentDate.isValid()) {
                return _this.props.invalidDateMessage;
            }
            else {
                return momentDate.format(_this.props.format);
            }
        };
        _this.getStateKeysAndValuesForBoundary = function (boundary) {
            var controlledRange = dateUtils_1.fromDateRangeToMomentDateRange(_this.props.value);
            if (boundary === dateUtils_1.DateRangeBoundary.START) {
                return {
                    keys: {
                        hoverString: "startHoverString",
                        inputString: "startInputString",
                        isInputFocused: "isStartInputFocused",
                        selectedValue: "selectedStart",
                    },
                    values: {
                        controlledValue: (controlledRange != null) ? controlledRange[0] : undefined,
                        hoverString: _this.state.startHoverString,
                        inputString: _this.state.startInputString,
                        isInputFocused: _this.state.isStartInputFocused,
                        selectedValue: _this.state.selectedStart,
                    },
                };
            }
            else {
                return {
                    keys: {
                        hoverString: "endHoverString",
                        inputString: "endInputString",
                        isInputFocused: "isEndInputFocused",
                        selectedValue: "selectedEnd",
                    },
                    values: {
                        controlledValue: (controlledRange != null) ? controlledRange[1] : undefined,
                        hoverString: _this.state.endHoverString,
                        inputString: _this.state.endInputString,
                        isInputFocused: _this.state.isEndInputFocused,
                        selectedValue: _this.state.selectedEnd,
                    },
                };
            }
        };
        _this.getDateRangeForCallback = function (currValue, currBoundary) {
            var otherBoundary = _this.getOtherBoundary(currBoundary);
            var otherValue = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;
            var currDate = _this.getDateForCallback(currValue);
            var otherDate = _this.getDateForCallback(otherValue);
            return (currBoundary === dateUtils_1.DateRangeBoundary.START)
                ? [currDate, otherDate]
                : [otherDate, currDate];
        };
        _this.getDateForCallback = function (momentDate) {
            if (dateUtils_1.isMomentNull(momentDate)) {
                return null;
            }
            else if (!momentDate.isValid()) {
                return new Date(undefined);
            }
            else {
                return dateUtils_1.fromMomentToDate(momentDate);
            }
        };
        _this.getOtherBoundary = function (boundary) {
            return (boundary === dateUtils_1.DateRangeBoundary.START) ? dateUtils_1.DateRangeBoundary.END : dateUtils_1.DateRangeBoundary.START;
        };
        _this.areSameDay = function (a, b) {
            return a.diff(b, "days") === 0;
        };
        _this.doBoundaryDatesOverlap = function (boundaryDate, boundary) {
            var otherBoundary = _this.getOtherBoundary(boundary);
            var otherBoundaryDate = _this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;
            // TODO: add handling for allowSingleDayRange (#249)
            if (boundary === dateUtils_1.DateRangeBoundary.START) {
                return boundaryDate.isSameOrAfter(otherBoundaryDate);
            }
            else {
                return boundaryDate.isSameOrBefore(otherBoundaryDate);
            }
        };
        /**
         * Returns true if the provided boundary is an END boundary overlapping the
         * selected start date. (If the boundaries overlap, we consider the END
         * boundary to be erroneous.)
         */
        _this.doesEndBoundaryOverlapStartBoundary = function (boundaryDate, boundary) {
            return (boundary === dateUtils_1.DateRangeBoundary.START)
                ? false
                : _this.doBoundaryDatesOverlap(boundaryDate, boundary);
        };
        _this.isControlled = function () {
            return _this.props.value !== undefined;
        };
        _this.isInputEmpty = function (inputString) {
            return inputString == null || inputString.length === 0;
        };
        _this.isInputInErrorState = function (boundary) {
            var values = _this.getStateKeysAndValuesForBoundary(boundary).values;
            var isInputFocused = values.isInputFocused, inputString = values.inputString, selectedValue = values.selectedValue;
            var boundaryValue = (isInputFocused)
                ? _this.dateStringToMoment(inputString)
                : selectedValue;
            // break down the boolean logic to an elementary level to make it
            // utterly simple to grok.
            if (dateUtils_1.isMomentNull(boundaryValue)) {
                return false;
            }
            if (!boundaryValue.isValid()) {
                return true;
            }
            if (!_this.isMomentInRange(boundaryValue)) {
                return true;
            }
            if (_this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)) {
                return true;
            }
            return false;
        };
        _this.isMomentValidAndInRange = function (momentDate) {
            return dateUtils_1.isMomentValidAndInRange(momentDate, _this.props.minDate, _this.props.maxDate);
        };
        _this.isMomentInRange = function (momentDate) {
            return dateUtils_1.isMomentInRange(momentDate, _this.props.minDate, _this.props.maxDate);
        };
        var _a = _this.getInitialRange(), selectedStart = _a[0], selectedEnd = _a[1];
        _this.state = {
            isOpen: false,
            selectedEnd: selectedEnd,
            selectedStart: selectedStart,
        };
        return _this;
    }
    DateRangeInput.prototype.componentDidUpdate = function () {
        if (this.shouldFocusInputRef(this.state.isStartInputFocused, this.startInputRef)) {
            this.startInputRef.focus();
        }
        else if (this.shouldFocusInputRef(this.state.isEndInputFocused, this.endInputRef)) {
            this.endInputRef.focus();
        }
    };
    DateRangeInput.prototype.render = function () {
        var _a = this.props, startInputProps = _a.startInputProps, endInputProps = _a.endInputProps;
        var startInputString = this.getInputDisplayString(dateUtils_1.DateRangeBoundary.START);
        var endInputString = this.getInputDisplayString(dateUtils_1.DateRangeBoundary.END);
        var popoverContent = (React.createElement(dateRangePicker_1.DateRangePicker, { onChange: this.handleDateRangePickerChange, onHoverChange: this.handleDateRangePickerHoverChange, maxDate: this.props.maxDate, minDate: this.props.minDate, boundaryToModify: this.state.boundaryToModify, value: this.getSelectedRange() }));
        var startInputClasses = classNames(startInputProps.className, (_b = {},
            _b[core_1.Classes.INTENT_DANGER] = this.isInputInErrorState(dateUtils_1.DateRangeBoundary.START),
            _b));
        var endInputClasses = classNames(endInputProps.className, (_c = {},
            _c[core_1.Classes.INTENT_DANGER] = this.isInputInErrorState(dateUtils_1.DateRangeBoundary.END),
            _c));
        // allow custom props for each input group, but pass them in an order
        // that guarantees only some props are overridable.
        return (React.createElement(core_1.Popover, { autoFocus: false, content: popoverContent, enforceFocus: false, inline: true, isOpen: this.state.isOpen, onClose: this.handlePopoverClose, position: core_1.Position.BOTTOM_LEFT },
            React.createElement("div", { className: core_1.Classes.CONTROL_GROUP },
                React.createElement(core_1.InputGroup, tslib_1.__assign({ placeholder: "Start date" }, startInputProps, { className: startInputClasses, disabled: this.props.disabled, inputRef: this.refHandlers.startInputRef, onBlur: this.handleStartInputBlur, onChange: this.handleStartInputChange, onClick: this.handleInputClick, onFocus: this.handleStartInputFocus, onKeyDown: this.handleInputKeyDown, onMouseDown: this.handleInputMouseDown, value: startInputString })),
                React.createElement(core_1.InputGroup, tslib_1.__assign({ placeholder: "End date" }, endInputProps, { className: endInputClasses, disabled: this.props.disabled, inputRef: this.refHandlers.endInputRef, onBlur: this.handleEndInputBlur, onChange: this.handleEndInputChange, onClick: this.handleInputClick, onFocus: this.handleEndInputFocus, onKeyDown: this.handleInputKeyDown, onMouseDown: this.handleInputMouseDown, value: endInputString })))));
        var _b, _c;
    };
    DateRangeInput.prototype.componentWillReceiveProps = function (nextProps) {
        _super.prototype.componentWillReceiveProps.call(this, nextProps);
        if (nextProps.value !== this.props.value) {
            var _a = this.getInitialRange(nextProps), selectedStart = _a[0], selectedEnd = _a[1];
            this.setState({ selectedStart: selectedStart, selectedEnd: selectedEnd });
        }
    };
    // Helpers
    // =======
    DateRangeInput.prototype.shouldFocusInputRef = function (isFocused, inputRef) {
        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;
    };
    DateRangeInput.prototype.isNextDateRangeValid = function (nextMomentDate, boundary) {
        return this.isMomentValidAndInRange(nextMomentDate)
            && !this.doBoundaryDatesOverlap(nextMomentDate, boundary);
    };
    return DateRangeInput;
}(core_1.AbstractComponent));
DateRangeInput.defaultProps = {
    closeOnSelection: true,
    disabled: false,
    endInputProps: {},
    format: "YYYY-MM-DD",
    invalidDateMessage: "Invalid date",
    maxDate: datePickerCore_1.getDefaultMaxDate(),
    minDate: datePickerCore_1.getDefaultMinDate(),
    outOfRangeMessage: "Out of range",
    overlappingDatesMessage: "Overlapping dates",
    startInputProps: {},
};
exports.DateRangeInput = DateRangeInput;

//# sourceMappingURL=dateRangeInput.js.map
