{"version":3,"sources":["../src/dateRangeInput.tsx"],"names":[],"mappings":"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","file":"dateRangeInput.js","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the BSD-3 License as modified (the “License”); you may obtain a copy\n * of the license at https://github.com/palantir/blueprint/blob/master/LICENSE\n * and https://github.com/palantir/blueprint/blob/master/PATENTS\n */\n\nimport * as classNames from \"classnames\";\nimport * as moment from \"moment\";\nimport * as React from \"react\";\n\nimport {\n    AbstractComponent,\n    Classes,\n    IInputGroupProps,\n    InputGroup,\n    IProps,\n    Keys,\n    Popover,\n    Position,\n    Utils,\n} from \"@blueprintjs/core\";\n\nimport {\n    DateRange,\n    DateRangeBoundary,\n    fromDateRangeToMomentDateRange,\n    fromMomentToDate,\n    isMomentInRange,\n    isMomentNull,\n    isMomentValidAndInRange,\n    MomentDateRange,\n} from \"./common/dateUtils\";\nimport {\n    getDefaultMaxDate,\n    getDefaultMinDate,\n    IDatePickerBaseProps,\n} from \"./datePickerCore\";\nimport {\n    DateRangePicker,\n} from \"./dateRangePicker\";\n\nexport interface IDateRangeInputProps extends IDatePickerBaseProps, IProps {\n\n    /**\n     * Whether the calendar popover should close when a date range is fully selected.\n     * @default true\n     */\n    closeOnSelection?: boolean;\n\n    /**\n     * The default date range to be used in the component when uncontrolled.\n     * This will be ignored if `value` is set.\n     */\n    defaultValue?: DateRange;\n\n    /**\n     * Whether the text inputs are non-interactive.\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Props to pass to the end-date input.\n     */\n    endInputProps?: IInputGroupProps;\n\n    /**\n     * The format of each date in the date range. See options\n     * here: http://momentjs.com/docs/#/displaying/format/\n     * @default \"YYYY-MM-DD\"\n     */\n    format?: string;\n\n    /**\n     * The error message to display when the selected date is invalid.\n     * @default \"Invalid date\"\n     */\n    invalidDateMessage?: string;\n\n    /**\n     * Called when the user selects a day.\n     * If no days are selected, it will pass `[null, null]`.\n     * If a start date is selected but not an end date, it will pass `[selectedDate, null]`.\n     * If both a start and end date are selected, it will pass `[startDate, endDate]`.\n     */\n    onChange?: (selectedRange: DateRange) => void;\n\n    /**\n     * Called when the user finishes typing in a new date and the date causes an error state.\n     * If the date is invalid, `new Date(undefined)` will be returned for the corresponding\n     * boundary of the date range.\n     * If the date is out of range, the out-of-range date will be returned for the corresponding\n     * boundary of the date range (`onChange` is not called in this case).\n     */\n    onError?: (errorRange: DateRange) => void;\n\n    /**\n     * The error message to display when the date selected is out of range.\n     * @default \"Out of range\"\n     */\n    outOfRangeMessage?: string;\n\n    /**\n     * The error message to display when the selected dates overlap.\n     * This can only happen when typing dates in the input field.\n     * @default \"Overlapping dates\"\n     */\n    overlappingDatesMessage?: string;\n\n    /**\n     * Props to pass to the start-date input.\n     */\n    startInputProps?: IInputGroupProps;\n\n    /**\n     * The currently selected date range.\n     * If this prop is present, the component acts in a controlled manner.\n     * To display no date range in the input fields, pass `[null, null]` to the value prop.\n     * To display an invalid date error in either input field, pass `new Date(undefined)`\n     * for the appropriate date in the value prop.\n     */\n    value?: DateRange;\n}\n\nexport interface IDateRangeInputState {\n    isOpen?: boolean;\n    boundaryToModify?: DateRangeBoundary;\n    lastFocusedField?: DateRangeBoundary;\n\n    isStartInputFocused?: boolean;\n    isEndInputFocused?: boolean;\n\n    startInputString?: string;\n    endInputString?: string;\n\n    startHoverString?: string;\n    endHoverString?: string;\n\n    selectedEnd?: moment.Moment;\n    selectedStart?: moment.Moment;\n\n    wasLastFocusChangeDueToHover?: boolean;\n};\n\ninterface IStateKeysAndValuesObject {\n    keys: {\n        hoverString: \"startHoverString\" | \"endHoverString\";\n        inputString: \"startInputString\" | \"endInputString\";\n        isInputFocused: \"isStartInputFocused\" | \"isEndInputFocused\";\n        selectedValue: \"selectedStart\" | \"selectedEnd\";\n    };\n    values: {\n        controlledValue?: moment.Moment,\n        hoverString?: string;\n        inputString?: string;\n        isInputFocused?: boolean;\n        selectedValue?: moment.Moment;\n    };\n};\n\nexport class DateRangeInput extends AbstractComponent<IDateRangeInputProps, IDateRangeInputState> {\n    public static defaultProps: IDateRangeInputProps = {\n        closeOnSelection: true,\n        disabled: false,\n        endInputProps: {},\n        format: \"YYYY-MM-DD\",\n        invalidDateMessage: \"Invalid date\",\n        maxDate: getDefaultMaxDate(),\n        minDate: getDefaultMinDate(),\n        outOfRangeMessage: \"Out of range\",\n        overlappingDatesMessage: \"Overlapping dates\",\n        startInputProps: {},\n    };\n\n    public displayName = \"Blueprint.DateRangeInput\";\n\n    private startInputRef: HTMLInputElement;\n    private endInputRef: HTMLInputElement;\n    private refHandlers = {\n        endInputRef: (ref: HTMLInputElement) => {\n            this.endInputRef = ref;\n            Utils.safeInvoke(this.props.endInputProps.inputRef, ref);\n        },\n        startInputRef: (ref: HTMLInputElement) => {\n            this.startInputRef = ref;\n            Utils.safeInvoke(this.props.startInputProps.inputRef, ref);\n        },\n    };\n\n    public constructor(props: IDateRangeInputProps, context?: any) {\n        super(props, context);\n\n        const [selectedStart, selectedEnd] = this.getInitialRange();\n\n        this.state = {\n            isOpen: false,\n            selectedEnd,\n            selectedStart,\n        };\n    }\n\n    public componentDidUpdate() {\n        if (this.shouldFocusInputRef(this.state.isStartInputFocused, this.startInputRef)) {\n            this.startInputRef.focus();\n        } else if (this.shouldFocusInputRef(this.state.isEndInputFocused, this.endInputRef)) {\n            this.endInputRef.focus();\n        }\n    }\n\n    public render() {\n        const { startInputProps, endInputProps } = this.props;\n\n        const startInputString = this.getInputDisplayString(DateRangeBoundary.START);\n        const endInputString = this.getInputDisplayString(DateRangeBoundary.END);\n\n        const popoverContent = (\n            <DateRangePicker\n                onChange={this.handleDateRangePickerChange}\n                onHoverChange={this.handleDateRangePickerHoverChange}\n                maxDate={this.props.maxDate}\n                minDate={this.props.minDate}\n                boundaryToModify={this.state.boundaryToModify}\n                value={this.getSelectedRange()}\n            />\n        );\n\n        const startInputClasses = classNames(startInputProps.className, {\n            [Classes.INTENT_DANGER]: this.isInputInErrorState(DateRangeBoundary.START),\n        });\n        const endInputClasses = classNames(endInputProps.className, {\n            [Classes.INTENT_DANGER]: this.isInputInErrorState(DateRangeBoundary.END),\n        });\n\n        // allow custom props for each input group, but pass them in an order\n        // that guarantees only some props are overridable.\n        return (\n            <Popover\n                autoFocus={false}\n                content={popoverContent}\n                enforceFocus={false}\n                inline={true}\n                isOpen={this.state.isOpen}\n                onClose={this.handlePopoverClose}\n                position={Position.BOTTOM_LEFT}\n            >\n                <div className={Classes.CONTROL_GROUP}>\n                    <InputGroup\n                        placeholder=\"Start date\"\n                        {...startInputProps}\n                        className={startInputClasses}\n                        disabled={this.props.disabled}\n                        inputRef={this.refHandlers.startInputRef}\n                        onBlur={this.handleStartInputBlur}\n                        onChange={this.handleStartInputChange}\n                        onClick={this.handleInputClick}\n                        onFocus={this.handleStartInputFocus}\n                        onKeyDown={this.handleInputKeyDown}\n                        onMouseDown={this.handleInputMouseDown}\n                        value={startInputString}\n                    />\n                    <InputGroup\n                        placeholder=\"End date\"\n                        {...endInputProps}\n                        className={endInputClasses}\n                        disabled={this.props.disabled}\n                        inputRef={this.refHandlers.endInputRef}\n                        onBlur={this.handleEndInputBlur}\n                        onChange={this.handleEndInputChange}\n                        onClick={this.handleInputClick}\n                        onFocus={this.handleEndInputFocus}\n                        onKeyDown={this.handleInputKeyDown}\n                        onMouseDown={this.handleInputMouseDown}\n                        value={endInputString}\n                    />\n                </div>\n            </Popover>\n        );\n    }\n\n    public componentWillReceiveProps(nextProps: IDateRangeInputProps) {\n        super.componentWillReceiveProps(nextProps);\n        if (nextProps.value !== this.props.value) {\n            const [selectedStart, selectedEnd] = this.getInitialRange(nextProps);\n            this.setState({ selectedStart, selectedEnd });\n        }\n    }\n\n    // Callbacks - DateRangePicker\n    // ===========================\n\n    private handleDateRangePickerChange = (selectedRange: DateRange) => {\n        if (this.props.value === undefined) {\n            const [selectedStart, selectedEnd] = fromDateRangeToMomentDateRange(selectedRange);\n\n            let isOpen = true;\n\n            let isStartInputFocused: boolean;\n            let isEndInputFocused: boolean;\n\n            let startHoverString: string;\n            let endHoverString: string;\n\n            if (isMomentNull(selectedStart)) {\n                // focus the start field by default or if only an end date is specified\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n\n                // for clarity, hide the hover string until the mouse moves over a different date\n                startHoverString = null;\n            } else if (isMomentNull(selectedEnd)) {\n                // focus the end field if a start date is specified\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n\n                endHoverString = null;\n            } else if (this.props.closeOnSelection) {\n                isOpen = false;\n                isStartInputFocused = false;\n                isEndInputFocused = false;\n            } else if (this.state.lastFocusedField === DateRangeBoundary.START) {\n                // keep the start field focused\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            } else {\n                // keep the end field focused\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n\n            this.setState({\n                isOpen,\n                selectedEnd,\n                selectedStart,\n                isEndInputFocused,\n                isStartInputFocused,\n                startHoverString,\n                endHoverString,\n                endInputString: this.getFormattedDateString(selectedEnd),\n                startInputString: this.getFormattedDateString(selectedStart),\n                wasLastFocusChangeDueToHover: false,\n            });\n        }\n        Utils.safeInvoke(this.props.onChange, selectedRange);\n    }\n\n    private handleDateRangePickerHoverChange = (hoveredRange: DateRange) => {\n        if (hoveredRange == null) {\n            // undo whatever focus changes we made while hovering\n            // over various calendar dates\n            const isEndInputFocused = (this.state.boundaryToModify === DateRangeBoundary.END);\n            const isStartInputFocused = !isEndInputFocused;\n            const lastFocusedField = (isEndInputFocused) ? DateRangeBoundary.END : DateRangeBoundary.START;\n\n            this.setState({\n                isEndInputFocused,\n                isStartInputFocused,\n                lastFocusedField,\n                endHoverString: null,\n                startHoverString: null,\n            });\n            return;\n        }\n\n        const { selectedStart, selectedEnd, boundaryToModify } = this.state;\n\n        const [hoveredStart, hoveredEnd] = fromDateRangeToMomentDateRange(hoveredRange);\n        const [startHoverString, endHoverString] = [hoveredStart, hoveredEnd].map(this.getFormattedDateString);\n        const [isHoveredStartDefined, isHoveredEndDefined] = [hoveredStart, hoveredEnd].map((d) => !isMomentNull(d));\n        const [isStartDateSelected, isEndDateSelected] = [selectedStart, selectedEnd].map((d) => !isMomentNull(d));\n\n        const isModifyingStartBoundary = boundaryToModify === DateRangeBoundary.START;\n\n        // pull the existing values from state; we may not overwrite them.\n        let { isStartInputFocused, isEndInputFocused } = this.state;\n\n        if (isStartDateSelected && isEndDateSelected) {\n            if (isHoveredStartDefined && isHoveredEndDefined) {\n                if (this.areSameDay(hoveredStart, selectedStart)) {\n                    // we'd be modifying the end date on click\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                } else if (this.areSameDay(hoveredEnd, selectedEnd)) {\n                    // we'd be modifying the start date on click\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                }\n            } else if (isHoveredStartDefined) {\n                if (isModifyingStartBoundary) {\n                    // we'd be specifying a new start date and clearing the end date on click\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                } else {\n                    // we'd be deselecting the end date on click\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                }\n            } else if (isHoveredEndDefined) {\n                if (isModifyingStartBoundary) {\n                    // we'd be deselecting the start date on click\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                } else {\n                    // we'd be specifying a new end date (clearing the start date) on click\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                }\n            }\n        } else if (isStartDateSelected) {\n            if (isHoveredStartDefined && isHoveredEndDefined) {\n                if (this.areSameDay(hoveredStart, selectedStart)) {\n                    // we'd be modifying the end date on click, so focus the end field\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                } else if (this.areSameDay(hoveredEnd, selectedStart)) {\n                    // we'd be modifying the start date on click, so focus the start field\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                }\n            } else if (isHoveredStartDefined) {\n                // we'd be replacing the start date on click\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            } else if (isHoveredEndDefined) {\n                // we'd be converting the selected start date to an end date\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            }\n        } else if (isEndDateSelected) {\n            if (isHoveredStartDefined && isHoveredEndDefined) {\n                if (this.areSameDay(hoveredEnd, selectedEnd)) {\n                    // we'd be modifying the start date on click\n                    isStartInputFocused = true;\n                    isEndInputFocused = false;\n                } else if (this.areSameDay(hoveredStart, selectedEnd)) {\n                    // we'd be modifying the end date on click\n                    isStartInputFocused = false;\n                    isEndInputFocused = true;\n                }\n            } else if (isHoveredEndDefined) {\n                // we'd be replacing the end date on click\n                isStartInputFocused = false;\n                isEndInputFocused = true;\n            } else if (isHoveredStartDefined) {\n                // we'd be converting the selected end date to a start date\n                isStartInputFocused = true;\n                isEndInputFocused = false;\n            }\n        }\n\n        this.setState({\n            startHoverString,\n            endHoverString,\n            isStartInputFocused,\n            isEndInputFocused,\n            lastFocusedField: (isStartInputFocused) ? DateRangeBoundary.START : DateRangeBoundary.END,\n            wasLastFocusChangeDueToHover: true,\n        });\n    }\n\n    // Callbacks - Input\n    // =================\n\n    // Key down\n\n    // add a keydown listener to persistently change focus when tabbing:\n    // - if focused in start field, Tab moves focus to end field\n    // - if focused in end field, Shift+Tab moves focus to start field\n    private handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n        const isTabPressed = e.keyCode === Keys.TAB;\n        const isShiftPressed = e.shiftKey;\n\n        // order of JS events is our enemy here. when tabbing between fields,\n        // this handler will fire in the middle of a focus exchange when no\n        // field is currently focused. we work around this by referring to the\n        // most recently focused field, rather than the currently focused field.\n        const wasStartFieldFocused = this.state.lastFocusedField === DateRangeBoundary.START;\n        const wasEndFieldFocused = this.state.lastFocusedField === DateRangeBoundary.END;\n\n        let isEndInputFocused: boolean;\n        let isStartInputFocused: boolean;\n\n        // move focus to the other field\n        if (wasStartFieldFocused && isTabPressed && !isShiftPressed) {\n            isStartInputFocused = false;\n            isEndInputFocused = true;\n        } else if (wasEndFieldFocused && isTabPressed && isShiftPressed) {\n            isStartInputFocused = true;\n            isEndInputFocused = false;\n        } else {\n            // let the default keystroke happen without side effects\n            return;\n        }\n\n        // prevent the default focus-change behavior to avoid race conditions;\n        // we'll handle the focus change ourselves in componentDidUpdate.\n        e.preventDefault();\n\n        this.setState({\n            isStartInputFocused,\n            isEndInputFocused,\n            wasLastFocusChangeDueToHover: false,\n        });\n    }\n\n    // Mouse down\n\n    private handleInputMouseDown = () => {\n        // clicking in the field constitutes an explicit focus change. we update\n        // the flag on \"mousedown\" instead of on \"click\", because it needs to be\n        // set before onFocus is called (\"click\" triggers after \"focus\").\n        this.setState({ wasLastFocusChangeDueToHover: false });\n    }\n\n    // Click\n\n    private handleInputClick = (e: React.MouseEvent<HTMLInputElement>) => {\n        // unless we stop propagation on this event, a click within an input\n        // will close the popover almost as soon as it opens.\n        e.stopPropagation();\n    }\n\n    // Focus\n\n    private handleStartInputFocus = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputFocus(e, DateRangeBoundary.START);\n    }\n\n    private handleEndInputFocus = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputFocus(e, DateRangeBoundary.END);\n    }\n\n    private handleInputFocus = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const inputString = this.getFormattedDateString(values.selectedValue);\n\n        // change the boundary only if the user explicitly focused in the field.\n        // focus changes from hovering don't count; they're just temporary.\n        const boundaryToModify = (this.state.wasLastFocusChangeDueToHover)\n            ? this.state.boundaryToModify\n            : boundary;\n\n        this.setState({\n            isOpen: true,\n            boundaryToModify,\n            [keys.inputString]: inputString,\n            [keys.isInputFocused]: true,\n            lastFocusedField: boundary,\n            wasLastFocusChangeDueToHover: false,\n        });\n    }\n\n    // Blur\n\n    private handleStartInputBlur = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputBlur(e, DateRangeBoundary.START);\n    }\n\n    private handleEndInputBlur = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputBlur(e, DateRangeBoundary.END);\n    }\n\n    private handleInputBlur = (_e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const { keys, values } = this.getStateKeysAndValuesForBoundary(boundary);\n\n        const maybeNextValue = this.dateStringToMoment(values.inputString);\n        const isValueControlled = this.isControlled();\n\n        if (this.isInputEmpty(values.inputString)) {\n            if (isValueControlled) {\n                this.setState({\n                    [keys.isInputFocused]: false,\n                    [keys.inputString]: this.getFormattedDateString(values.controlledValue),\n                });\n            } else {\n                this.setState({\n                    [keys.isInputFocused]: false,\n                    [keys.selectedValue]: moment(null),\n                    [keys.inputString]: null,\n                });\n            }\n        } else if (!this.isNextDateRangeValid(maybeNextValue, boundary)) {\n            if (isValueControlled) {\n                this.setState({ [keys.isInputFocused]: false });\n            } else {\n                this.setState({\n                    [keys.isInputFocused]: false,\n                    [keys.inputString]: null,\n                    [keys.selectedValue]: maybeNextValue,\n                });\n            }\n            Utils.safeInvoke(this.props.onError, this.getDateRangeForCallback(maybeNextValue, boundary));\n        } else {\n            this.setState({ [keys.isInputFocused]: false });\n        }\n    }\n\n    // Change\n\n    private handleStartInputChange = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputChange(e, DateRangeBoundary.START);\n        Utils.safeInvoke(this.props.startInputProps.onChange, e);\n    }\n\n    private handleEndInputChange = (e: React.FormEvent<HTMLInputElement>) => {\n        this.handleInputChange(e, DateRangeBoundary.END);\n        Utils.safeInvoke(this.props.endInputProps.onChange, e);\n    }\n\n    private handleInputChange = (e: React.FormEvent<HTMLInputElement>, boundary: DateRangeBoundary) => {\n        const inputString = (e.target as HTMLInputElement).value;\n\n        const { keys } = this.getStateKeysAndValuesForBoundary(boundary);\n        const maybeNextValue = this.dateStringToMoment(inputString);\n        const isValueControlled = this.isControlled();\n\n        if (inputString.length === 0) {\n            // this case will be relevant when we start showing the hovered\n            // range in the input fields. goal is to show an empty field for\n            // clarity until the mouse moves over a different date.\n            if (isValueControlled) {\n                this.setState({ [keys.inputString]: \"\" });\n            } else {\n                this.setState({ [keys.inputString]: \"\", [keys.selectedValue]: moment(null) });\n            }\n            Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(moment(null), boundary));\n        } else if (this.isMomentValidAndInRange(maybeNextValue)) {\n            // note that error cases that depend on both fields (e.g.\n            // overlapping dates) should fall through into this block so that\n            // the UI can update immediately, possibly with an error message on\n            // the other field.\n            if (isValueControlled) {\n                this.setState({ [keys.inputString]: inputString });\n            } else {\n                this.setState({ [keys.inputString]: inputString, [keys.selectedValue]: maybeNextValue });\n            }\n            if (this.isNextDateRangeValid(maybeNextValue, boundary)) {\n                Utils.safeInvoke(this.props.onChange, this.getDateRangeForCallback(maybeNextValue, boundary));\n            }\n        } else {\n            this.setState({ [keys.inputString]: inputString });\n        }\n    }\n\n    // Callbacks - Popover\n    // ===================\n\n    private handlePopoverClose = () => {\n        this.setState({ isOpen: false });\n    }\n\n    // Helpers\n    // =======\n\n    private shouldFocusInputRef(isFocused: boolean, inputRef: HTMLInputElement) {\n        return isFocused && inputRef !== undefined && document.activeElement !== inputRef;\n    }\n\n    private dateStringToMoment = (dateString: string) => {\n        if (this.isInputEmpty(dateString)) {\n            return moment(null);\n        }\n        return moment(dateString, this.props.format);\n    }\n\n    private getInitialRange = (props = this.props) => {\n        const { defaultValue, value } = props;\n        if (value != null) {\n            return fromDateRangeToMomentDateRange(value);\n        } else if (defaultValue != null) {\n            return fromDateRangeToMomentDateRange(defaultValue);\n        } else {\n            return [moment(null), moment(null)] as MomentDateRange;\n        }\n    }\n\n    private getSelectedRange = () => {\n        const momentDateRange = [this.state.selectedStart, this.state.selectedEnd] as MomentDateRange;\n        const [startDate, endDate] = momentDateRange.map((selectedBound?: moment.Moment) => {\n            return this.isMomentValidAndInRange(selectedBound)\n                ? fromMomentToDate(selectedBound)\n                : undefined;\n        });\n        // show only the start date if the dates overlap\n        // TODO: add different handling for the === case once\n        // allowSingleDayRange is implemented (#249)\n        return [startDate, (startDate >= endDate) ? null : endDate] as DateRange;\n    }\n\n    private getInputDisplayString = (boundary: DateRangeBoundary) => {\n        const { values } = this.getStateKeysAndValuesForBoundary(boundary);\n        const { isInputFocused, inputString, selectedValue, hoverString } = values;\n\n        if (hoverString != null && !this.isControlled()) {\n            // we don't want to overwrite the inputStrings in controlled mode\n            return hoverString;\n        } else if (isInputFocused) {\n            return (inputString == null) ? \"\" : inputString;\n        } else if (isMomentNull(selectedValue)) {\n            return \"\";\n        } else if (!this.isMomentInRange(selectedValue)) {\n            return this.props.outOfRangeMessage;\n        } else if (this.doesEndBoundaryOverlapStartBoundary(selectedValue, boundary)) {\n            return this.props.overlappingDatesMessage;\n        } else {\n            return this.getFormattedDateString(selectedValue);\n        }\n    }\n\n    private getFormattedDateString = (momentDate: moment.Moment) => {\n        if (isMomentNull(momentDate)) {\n            return \"\";\n        } else if (!momentDate.isValid()) {\n            return this.props.invalidDateMessage;\n        } else {\n            return momentDate.format(this.props.format);\n        }\n    }\n\n    private getStateKeysAndValuesForBoundary = (boundary: DateRangeBoundary) => {\n        const controlledRange = fromDateRangeToMomentDateRange(this.props.value);\n        if (boundary === DateRangeBoundary.START) {\n            return {\n                keys: {\n                    hoverString: \"startHoverString\",\n                    inputString: \"startInputString\",\n                    isInputFocused: \"isStartInputFocused\",\n                    selectedValue: \"selectedStart\",\n                },\n                values: {\n                    controlledValue: (controlledRange != null) ? controlledRange[0] : undefined,\n                    hoverString: this.state.startHoverString,\n                    inputString: this.state.startInputString,\n                    isInputFocused: this.state.isStartInputFocused,\n                    selectedValue: this.state.selectedStart,\n                },\n            } as IStateKeysAndValuesObject;\n        } else {\n            return {\n                keys: {\n                    hoverString: \"endHoverString\",\n                    inputString: \"endInputString\",\n                    isInputFocused: \"isEndInputFocused\",\n                    selectedValue: \"selectedEnd\",\n                },\n                values: {\n                    controlledValue: (controlledRange != null) ? controlledRange[1] : undefined,\n                    hoverString: this.state.endHoverString,\n                    inputString: this.state.endInputString,\n                    isInputFocused: this.state.isEndInputFocused,\n                    selectedValue: this.state.selectedEnd,\n                },\n            } as IStateKeysAndValuesObject;\n        }\n    }\n\n    private getDateRangeForCallback = (currValue?: moment.Moment, currBoundary?: DateRangeBoundary) => {\n        const otherBoundary = this.getOtherBoundary(currBoundary);\n        const otherValue = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        const currDate = this.getDateForCallback(currValue);\n        const otherDate = this.getDateForCallback(otherValue);\n\n        return (currBoundary === DateRangeBoundary.START)\n            ? [currDate, otherDate]\n            : [otherDate, currDate];\n    }\n\n    private getDateForCallback = (momentDate: moment.Moment) => {\n        if (isMomentNull(momentDate)) {\n            return null;\n        } else if (!momentDate.isValid()) {\n            return new Date(undefined);\n        } else {\n            return fromMomentToDate(momentDate);\n        }\n    }\n\n    private getOtherBoundary = (boundary?: DateRangeBoundary) => {\n        return (boundary === DateRangeBoundary.START) ? DateRangeBoundary.END : DateRangeBoundary.START;\n    }\n\n    private areSameDay = (a: moment.Moment, b: moment.Moment) => {\n        return a.diff(b, \"days\") === 0;\n    }\n\n    private doBoundaryDatesOverlap = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        const otherBoundary = this.getOtherBoundary(boundary);\n        const otherBoundaryDate = this.getStateKeysAndValuesForBoundary(otherBoundary).values.selectedValue;\n\n        // TODO: add handling for allowSingleDayRange (#249)\n        if (boundary === DateRangeBoundary.START) {\n            return boundaryDate.isSameOrAfter(otherBoundaryDate);\n        } else {\n            return boundaryDate.isSameOrBefore(otherBoundaryDate);\n        }\n    }\n\n    /**\n     * Returns true if the provided boundary is an END boundary overlapping the\n     * selected start date. (If the boundaries overlap, we consider the END\n     * boundary to be erroneous.)\n     */\n    private doesEndBoundaryOverlapStartBoundary = (boundaryDate: moment.Moment, boundary: DateRangeBoundary) => {\n        return (boundary === DateRangeBoundary.START)\n            ? false\n            : this.doBoundaryDatesOverlap(boundaryDate, boundary);\n    }\n\n    private isControlled = () => {\n        return this.props.value !== undefined;\n    }\n\n    private isInputEmpty = (inputString: string) => {\n        return inputString == null || inputString.length === 0;\n    }\n\n    private isInputInErrorState = (boundary: DateRangeBoundary) => {\n        const values = this.getStateKeysAndValuesForBoundary(boundary).values;\n        const { isInputFocused, inputString, selectedValue } = values;\n\n        const boundaryValue = (isInputFocused)\n            ? this.dateStringToMoment(inputString)\n            : selectedValue;\n\n        // break down the boolean logic to an elementary level to make it\n        // utterly simple to grok.\n\n        if (isMomentNull(boundaryValue)) {\n            return false;\n        }\n\n        if (!boundaryValue.isValid()) {\n            return true;\n        }\n\n        if (!this.isMomentInRange(boundaryValue)) {\n            return true;\n        }\n\n        if (this.doesEndBoundaryOverlapStartBoundary(boundaryValue, boundary)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private isMomentValidAndInRange = (momentDate: moment.Moment) => {\n        return isMomentValidAndInRange(momentDate, this.props.minDate, this.props.maxDate);\n    }\n\n    private isMomentInRange = (momentDate: moment.Moment) => {\n        return isMomentInRange(momentDate, this.props.minDate, this.props.maxDate);\n    }\n\n    private isNextDateRangeValid(nextMomentDate: moment.Moment, boundary: DateRangeBoundary) {\n        return this.isMomentValidAndInRange(nextMomentDate)\n            && !this.doBoundaryDatesOverlap(nextMomentDate, boundary);\n    }\n}\n"]}